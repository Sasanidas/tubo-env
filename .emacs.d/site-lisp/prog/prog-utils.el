;;; prog-utils.el -- Brief introduction here.

;;; Commentary:

;;; Code:


(use-package dash-at-point
  :commands (dash-at-point))

(use-package zeal-at-point
  :commands (zeal-at-point))


(defun yc/doc-at-point (&optional edit-search)
  "Call doc at point.."
  (interactive "P")
  (if (string= system-type "darwin")
      (dash-at-point edit-search)
    (zeal-at-point edit-search)))

(defun yc/insert-single-comment ()
  "Insert signle line of comment using srecode."
  (interactive)
  (condition-case err
      (progn
        (srecode-load-tables-for-mode major-mode)
        (yc/remove-empty-lines (point-min))
        (srecode-insert "declaration:comment-single-line"))
    (error (insert " /* */"))))



;;;###autoload
(defun yc/format-files ()
  "Format all files in `default-directory'."
  (interactive)
  (save-excursion
    (dolist (fn (directory-files default-directory nil
                                 (rx "." (or "c" "cpp" "cc" "cxx" "h" "hpp") eol)))

      (with-current-buffer (find-file-noselect fn)
        (clang-format-buffer)
        (save-buffer)
        (kill-buffer)))))


(defun yc/asm-post-process-objdump ()
  "Post process for asm file generated by `objdump'."
  (PDEBUG "asm post process for objdump")
  (let ((r-match-func  (rx bol  (+ alnum) (+ space) "<" (+ (or "_" alnum)) ">:" eol))
        (r-match-addr  (rx (+ space) (group (+ alnum)) ":" space))
        (r-match-codes (rx ":" (+ space) (* (repeat 2 alnum) space ) (* space)))
        (r-match-offset (rx "+" "0x" (group (+ alnum))  ">"))
        pos )

    (defun get-address ()
      "Get address"
      (if (looking-at r-match-addr)
          (let* ((m-data (match-data 1))
                 (addr-str (buffer-substring-no-properties (nth 2 m-data) (nth 3 m-data))))
            (string-to-number addr-str 16))))

    ;; first, add a space around "+"
    (save-excursion
      (while (search-forward-regexp r-match-offset nil t)
        (replace-match "+ 0x\\1 >"))
      )

    ;; then, remove instruction codes...
    (save-excursion
      (while (search-forward-regexp r-match-codes nil t)
        (replace-match ":	")))

    ;; last, calculate offset for instruction addresses.
    (save-excursion
      (while (setq pos (search-forward-regexp r-match-func nil t))
        (let* ((pos (1+ pos))
               (end (or (search-forward-regexp r-match-func nil t)
                        (point-max))))
          (goto-char end)
          (setq end (point-at-eol -1)) ;; update end position, we'll go back here later.
          (goto-char pos)
          (aif (get-address)
              (while (<= pos end)
                (goto-char pos)
                (unless (looking-at-p (rx (or (: bol eol)
                                              (: (* space)";" ))))
                  (let* ((addr (get-address))
                         (tmp-string (format "0x%x" (- addr it)))
                         (off-string (format "%s%s" tmp-string
                                             (make-string
                                              (- 7 (length tmp-string)) ? ))))
                    (insert off-string)
                    (setq end (+ end (length off-string)))))
                (setq pos (point-at-bol 2))))
          (goto-char end)
          (forward-line -1))))))

(defun yc/asm-post-process-gdb ()
  "Post process for asm file generated by `gdb'."
  (interactive)
  (PDEBUG "asm post process for gdb")
  (let ((r-match-offset (rx "<" (group "+" (+ digit)  ">:")))
        (r-match-offset-funcall (rx (group "<" (+? (or alnum "_"))) "+"
                                    (group (+ digit)  ">") eol) ))

    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp r-match-offset nil t)
        ;; (replace-match "< \\1\t\t")
        (let* ((str (match-string 1)))
          (replace-match (format "< %s%s" str (if (> (length str) 5) "" "\t")))
          )
        ))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp r-match-offset-funcall nil t)
        (replace-match "\\1 +\\2")))))

;;;###autoload
(defun yc/asm-post-process ()
  "Add offset to current file."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (cond
     ((looking-at-p (rx "Dump of assembler code for function"))
      (yc/asm-post-process-gdb))
     (t (yc/asm-post-process-objdump)))))


;; ================================== My STRING utils ========================
(defun eassist-string-without-last (string n)
  "This function truncates from the STRING last N characters."
  (substring string 0 (max 0(- (length string) n))))

(defun eassist-string-ends-with (string end)
  "Check whether STRING ends with END substring."
  (string= end (substring string (- (length end)))))
;; ================================== My STRING utils end ====================

;; ================================== CPP-H switch ===========================
;;;###autoload
(defvar eassist-header-switches '(("h" . ("cpp" "cc" "c" "cxx" "C" "m" "mm"))
				  ("hpp" . ("cpp" "cc" "cxx"))
				  ("cpp" . ("h" "hpp"))
                  ("cxx" . ("h" "hpp"))
				  ("c" . ("h" ))
				  ("C" . ("H"))
				  ("H" . ("C" "CPP" "CC"))
				  ("cc" . ("h" "hpp")))
  "This variable defines possible switches for `eassist-switch-h-cpp' function.
Its format is list of (from . (to1 to2 to3...)) elements.  From and toN are
strings which are extentions of the files.")

;;;###autoload
(defun eassist-switch-h-cpp ()
  "Switch header and body file according to `eassist-header-switches' var.
The current buffer's file name extention is searched in
`eassist-header-switches' variable to find out extention for file's counterpart,
for example *.hpp <--> *.cpp."
  (interactive)
  (let* ((ext (file-name-extension (buffer-file-name)))
         (base-name (eassist-string-without-last (buffer-name) (length ext)))
         (base-path (eassist-string-without-last (buffer-file-name) (length ext)))
         (count-ext (cdr (find-if (lambda (i) (string= (car i) ext)) eassist-header-switches))))
    (cond
     (count-ext
      (unless
          (or
           (loop for b in (mapcar (lambda (i) (concat base-name i)) count-ext)
		 when (bufferp (get-buffer b)) return
 		 (if (get-buffer-window b)
 		     (switch-to-buffer-other-window b)
 		   (if (get-buffer-window b t)
 		       (switch-to-buffer-other-frame b)
 		     (switch-to-buffer b))))
           (loop for c in (mapcar (lambda (count-ext) (concat base-path count-ext)) count-ext)
                 when (file-exists-p c) return (find-file c)))
        (error "There is no corresponding pair (header or body) file.")))
     (t
      (message "It is not a header or body file! See eassist-header-switches
variable.")))))



(defun yc/switch-h-cpp ()
  "Switch between headers and source files."
  (interactive)
  (let* ((tag (semantic-stickyfunc-tag-to-stick))
         (arg-exp "")
         func args
         exp-list)

    ;; TODO: parse and save location info...
    ;; (defun get-type-name (tag)
    ;;   "Get type name of TAG."
    ;;   (cond
    ;;    ((stringp tag) tag)
    ;;    ((semantic-tag-p tag) (semantic-tag-name tag))
    ;;    (t "")))

    ;; ;; prepare tags
    ;; (when (and tag (equal (semantic-tag-class tag) 'function))
    ;;   (setq func (semantic-tag-name tag)
    ;;         args (semantic-tag-get-attribute tag :arguments)))

    ;; ;; prepare exp-list which will be used to re-search
    ;; (when (and func args)
    ;;   (let (arg-list)
    ;;     (dolist (arg args)
    ;;       (setq arg-list (cons (get-type-name (semantic-tag-type arg)) arg-list )))
    ;;     (while arg-list
    ;;       (let ((tmp-list (copy-list arg-list)))
    ;;         (add-to-list
    ;;          'exp-list (format "%s[[:space:]]*([[:space:]]*%s.*?)"
    ;;                            func (s-join ".*?,[[:space:]]*"
    ;;                                         (nreverse tmp-list) )) t))
    ;;       (pop arg-list))))

    ;; (if func (add-to-list 'exp-list (format "%s[[:space:]]*(.*?)" func) t))

    ;; core of switch..
    (condition-case error
        (eassist-switch-h-cpp)
      (error (projectile-find-other-file)))

    ;; ;; TODO: try to find proper position to goto.
    ;; (when exp-list
    ;;   (let (pos)
    ;;     (while (and exp-list (not pos))
    ;;       (save-excursion
    ;;         (goto-char (point-min))
    ;;         (setq pos (re-search-forward (pop exp-list) nil t))))
    ;;     (if pos
    ;;         (goto-char (1- pos)))))
    ))

;; ================================== CPP-H switch end =========================



(defun yc/enable-disable-c-block (start end)
  "Enable or disable c blocks(START ~ END) using #if 0/#endif macro."
  (interactive "rp")
  (let* ((sep (rx (* space) "//" (+ space)))
         (if-0-start (concat "#if 0" sep "TODO: Remove this ifdef!\n"))
         (if-0-end   (concat "#endif" sep "End of #if 0"))
         (if-0-end-nl (concat "\n" if-0-end))
         (r-match-if0 (format "%s%s%s" if-0-start(rx (group (+? anything))) if-0-end)))
    (save-excursion
      (save-restriction
        (narrow-to-region start end)
        (goto-char (point-min))

        (if (and (looking-at r-match-if0)
                 (search-forward-regexp r-match-if0 end t))
            (replace-match "\\1")
          (goto-char end)
          (insert (if (looking-back "\n" ) if-0-end if-0-end-nl))
          (goto-char start)
          (insert if-0-start)


          (goto-char (point-min))
          (while (search-forward sep nil t)
            (replace-match " // "))))

      (indent-region start end))))

(defun yc/insert-empty-template ()
  "Make header based on srecode."
  (interactive)
  (save-excursion
    (srecode-load-tables-for-mode major-mode)
    (srecode-insert "file:empty")
    (delete-trailing-whitespace)))

(defun yc/header-make ()
  "Make header based on srecode."
  (interactive)
  (progn;save-excursion
    (goto-char (point-min))
    (while (looking-at (or comment-start-skip comment-start))
      (forward-line))
    (condition-case err
        (progn
          (srecode-load-tables-for-mode major-mode)
          (yc/remove-empty-lines (point-min))

          (srecode-insert "file:fileheader")
          (yc/remove-empty-lines (point-max))
          (goto-char (point-max))
          (srecode-insert "file:fileheader_end"))
      (error (srecode-insert "file:filecomment")))
    )
  (delete-trailing-whitespace))

(defun yc/preprocess-file ()
  "Pre-process current file.."
  (interactive)
  (lsp--cur-workspace-check)
  (-when-let* ((mode major-mode)
               (info (ccls-file-info))
               (args (seq-into (gethash "args" info) 'vector))
               (working-directory default-directory)
               (new-args (let ((i 0) ret)
                           (while (< i (length args))
                             (let ((arg (elt args i)))
                               (cond
                                ((string= arg "-o") (cl-incf i))
                                ((string-match-p "\\`-o.+" arg))
                                ((string-match "\\`-working-directory=\\(.+\\)" arg)
                                 (setq default-directory (match-string 1 arg)))
                                (t (push arg ret))))
                             (cl-incf i))
                           (nreverse ret))))

    (PDEBUG "DIR" (shell-command-to-string "pwd"))

    (with-current-buffer (get-buffer-create
                          (format "*lsp-ccls preprocess %s*" (buffer-name)))
      (pop-to-buffer (current-buffer))
      (with-silent-modifications
        (erase-buffer)
        (insert (format "// Generated by: %s"
                        (combine-and-quote-strings new-args)))
        (insert (with-output-to-string
                  (with-current-buffer standard-output
                    (apply #'process-file (car new-args) nil t nil "-E" (cdr new-args)))))
        (delay-mode-hooks (funcall mode))
        (setq buffer-read-only t)))))





(defun addr-2-line (app)
  "Call add2line with executable file set to `APP'."
  (interactive)
  (unless (file-exists-p app)
    (error "Can't find file %s" app))
  (unless (executable-find "addr2line")
    (error "Executable addr2line is not available"))

  (save-excursion
    (goto-char (point-min))
    (while (search-forward-regexp (rx ")[" (group "0x" (+ hex)) "]") nil t)
      (let* ((addr (match-string 1))
             (result (yc/command-output-to-string "addr2line" addr "-e" app)))
        (insert " " result))))

  (save-excursion
    (goto-char (point-min))
    (while (search-forward-regexp
            (rx (group "0x" (+ hex))       ;; addr
                (+ space)
                (group (*? nonl))          ;; function name
                "("
                (group (+? nonl))          ;; filename
                "+"
                (group "0x" (+ hex))       ;; offset
                ")") nil t)
      (print (point))

      (let* ((addr (match-string 1)))
        (if (string= (file-name-base app) (file-name-base (match-string 3)))
            (let ((result (yc/command-output-to-string "addr2line" addr "-e" app)))
              (replace-match (concat "\\1 \\2 " result))))))))

;;;###autoload
(defun c++filt-buffer ()
  "Call c++filt for current buffer."
  (interactive)
  (let ((exec (executable-find "c++filt"))
        (pmax (point-max))
        )
    (unless exec
      (error "Can't find c++filt"))

    (save-excursion
      (goto-char (point-max))
      (call-process-region (point-min) pmax exec nil t))
    (delete-region (point-min) pmax)))

(defvar gcrash--app-hist nil "Nil.")

;;;###autoload
(defun gcrash-analyze-buffer (&optional app)
  "Analyze current buffer.
It will do several things:
1. `c++filt' is called to demangled function names.
2. `addr2line' is called if APP is provided."
  (interactive)
  (unless app
    (setq app (completing-read "App: " gcrash--app-hist nil nil)))
  (c++filt-buffer)
  (addr-2-line app)
  (save-buffer))

;;;###autoload
(defun uniq-stack ()
  "Make stacks unique."
  (interactive)
  (let ((r-match-host (rx bol (+ "-") (* space)
                          (group  (+? (or alnum "." "-" "_")) )
                          (* space) (+ "-") eol))
        (obuf (get-buffer-create (format "Uniq-Stack of: %s" (buffer-name))))
        (nr-hosts 0) suspect-hosts)

    ;; prepare obuf
    (with-current-buffer obuf
      (read-only-mode -1)
      (erase-buffer))

    (defun uniq-single-host (start end &optional host)
      "Parse and make stack unique for single host. Return t if stack of this host is suspicious."
      (let ((r-match-thread (rx bol "Thread" (* space) (group (+ digit)) (* space)
                                "(Thread" (+? ascii) ":" eol))
            (r-match-suspicious (rx (+? ascii)
                                    (or "segfault" "segment fault" "signal handler called"
                                        "abort" "raise" "__assert_fail")
                                    (? space) (? "()")
                                    (+? ascii)))
            (htable-stack (make-hash-table :test 'equal :size 2048))
            (htable-threads (make-hash-table :test 'equal :size 2048))
            (nr-uniq 0)
            ordered-numbers suspects summary-pos)
        (save-excursion
          (goto-char start)
          (while (and (< (point) end)
                      (search-forward-regexp r-match-thread end t))
            (forward-char)
            (let* ((pos (point))
                   (endp (cond
                          ((search-forward-regexp r-match-thread end t) (point-at-bol))
                          (t end)))
                   (stack (buffer-substring-no-properties pos endp))
                   (num (gethash stack htable-stack 0)))
              (puthash stack (1+ num) htable-stack)
              (goto-char endp))))

        ;; Sort tacks based on number of threads.
        (maphash (lambda (stack repeated)
                   (let ((lst (gethash repeated htable-threads nil)))
                     (puthash repeated (cons stack lst) htable-threads))
                   (add-to-list 'ordered-numbers repeated)
                   ) htable-stack)
        (sort ordered-numbers '>)

        ;; Now insert stacks and highlight suspicious ones.
        (with-current-buffer obuf
          (read-only-mode -1)
          (goto-char (point-max))
          (message "Parsing stack of host: %s" host)
          (insert "\n\n========= Host " (or host "Unknown Host") ", ")
          (setq summary-pos (point))

          (dolist (number ordered-numbers)
            (let ((stack-list (gethash number htable-threads)))
              (dolist (stack stack-list)
                (setq nr-uniq (1+ nr-uniq))
                (insert (format "\nNumber of Threads: %d" number))
                (let (added-to-list)
                  (dolist (str (string-split stack "\n"))
                    (insert (format "\n%s" str))
                    (when (string-match r-match-suspicious str)
                      (unless added-to-list
                        (setq added-to-list t
                              suspects (cons (1+ (line-number-at-pos)) suspects)))
                      (overlay-put (make-overlay (point-at-bol) (point-at-eol))
                                   'face `(:underline (:style wave :color "Red1")))))))))
          (goto-char summary-pos)
          (insert (format "Unique Stacks: %d, suspicious lines: " nr-uniq))
          (if suspects
              (progn
                (setq suspects (nreverse suspects))
                (insert (format "%d" (pop suspects)))
                (while suspects
                  (insert (format ", %d" (pop suspects)))))
            (insert "none"))
          (insert ".=========\n"))
        suspects))

    (save-excursion
      (goto-char (point-min))
      (if (search-forward-regexp r-match-host nil t)
          (let ((host (match-string 1))
                (pos (match-end 0))
                host-next pos-end pos-next)
            (while (< pos (point-max))
              (if (search-forward-regexp r-match-host nil t) ;; ok, find next one
                  (setq host-next (match-string 1)
                        pos-next (point)
                        pos-end (1- (point-at-bol)))
                (setq host-next nil
                      pos-end (point-max)
                      pos-next (point-max)))
              (setq nr-hosts (1+ nr-hosts))
              (if (uniq-single-host pos pos-end host)
                  (setq suspect-hosts (cons host suspect-hosts)))
              (setq host host-next
                    pos pos-next)))
        (uniq-single-host (point-min)
                          (if (search-forward-regexp "^cmd:.*$" nil t)
                              (match-beginning 0)
                            (point-max)))))

    ;; show this buffer.
    (with-current-buffer obuf
      (when (> nr-hosts 0)
        (goto-char (point-min))
        (insert (format "Total hosts: %d" nr-hosts))
        (insert (if suspect-hosts
                    (format ", %d suspicious hosts: %s" (length suspect-hosts)
                            (mapconcat 'identity suspect-hosts ","))
                  ".")))

      (read-only-mode 1)
      (goto-char (point-min))
      (pop-to-buffer (current-buffer)))))



(defmacro string-concact (str &rest args)
  "Concat string STR and ARGS."
  `(setq ,str (funcall 'concat ,str ,@args)))

(defun parse_segfault ()
  "Parse segfault entry."
  (interactive)
  (let ((r-match-segfault
         (rx bol (? "[" (+ (or digit "."))"]" (+ space))
             (group (+? nonl))   ;; 1 -- app name
             "[" (+? digit) "]:" (+ space)
             "segfault at"     (+ space) (group (+ hex))   ;; 2 -- fault addr
             (+ space) "ip"    (+ space) (group (+ hex))   ;; 3 -- instruction pointer
             (+ space) "sp"    (+ space) (group (+ hex))   ;; 4 -- stack pointer
             (+ space) "error" (+ space) (group (+ digit)) ;; 5 -- error
             (+ space) "in"    (+ space) (group (+? nonl)) ;; 6 -- name of app or lib
             "[" (group (+ hex)) "+" (group (+ hex))       ;; 7 -- base addr, 8: size??
             "]" eol))
        (obuf (get-buffer-create (format "SegmentFault of: %s" (buffer-name)))))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp r-match-segfault nil t)
        (let* ((app (match-string 1))
               (addr (match-string 2))
               (ip (match-string 3))
               (sp (match-string 4))
               (err (match-string 5))
               (name (match-string 6))
               (base-addr (match-string 7))
               (msg (format "%s: segfault in %s" app name)))
          (setq addr   (string-to-number addr 16)
                ip   (string-to-number ip 16)
                sp   (string-to-number sp 16)
                err  (string-to-number err)
                base-addr (string-to-number base-addr 16))

          (string-concact msg (format " at adrress 0x%x, " addr))
          (string-concact msg (format "instruction pointer: 0x%x, " ip))
          ;; (string-concact msg (format "stack pointer: 0x%x," sp))
          (string-concact msg (format "fault offset 0x%x, Reason: " (- ip base-addr)))

          (cond
           ((= 1 (logand err 8)) (string-concact msg "use of reserved bit detected."))
           ((= 1 (logand err 16)) (string-concact msg "fault was an instruction fetch."))
           (t
            (string-concact msg (if (= 0 (logand err 1)) "no page found" "protection fault"))
            (string-concact msg " while executing "
                            (if (= 0 (logand err 2)) "read" "write") " operation")
            (string-concact msg " in "
                            (if (= 0 (logand err 4)) "kernel" "user") " mode.")))
          (with-current-buffer obuf
            (insert msg)
            (insert "\n")))))
    (display-buffer obuf)))



(provide 'prog-utils)

;; Local Variables:
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:

;;; prog-utils.el ends here
